import base64
import json
import time
from pathlib import Path

import httpx
from Crypto.Cipher import AES
from Crypto.Hash import MD5
from Crypto.Util.Padding import unpad

from src.core import logger

log = logger.get('cookiecloud')


class CookieCloudClient:
    def __init__(self, server_url: str, uuid: str, password: str, user_agent: str | None = None, proxy: str | None = None) -> None:
        """Initialize the CookieCloud client.

        Args:
            server_url (str): The URL of the CookieCloud server
            uuid (str): Your CookieCloud UUID
            password (str): Your CookieCloud password
            user_agent (str, optional): Custom user agent for requests

        """
        self.server_url = server_url.rstrip('/')
        self.uuid = uuid
        self.password = password
        self.user_agent = user_agent or 'CookieCloudClient/Python'
        self.client = httpx.Client(proxy=proxy, timeout=10, headers={'User-Agent': self.user_agent})
        self.key = MD5.new(f'{self.uuid}-{self.password}'.encode()).hexdigest()[:16].encode()

    def _decrypt_data(self, encrypted_text: str) -> str:
        # Decode the base64 encoded encrypted text
        encrypted_bytes = base64.b64decode(encrypted_text)

        if encrypted_bytes[:8] != b'Salted__':
            msg = 'Invalid OpenSSL encrypted text'
            raise ValueError(msg)

        salt = encrypted_bytes[8:16]

        # OpenSSL key derivation
        key_iv = b''
        prev = b''
        while len(key_iv) < 48:  # We need 32 bytes for key and 16 bytes for IV
            prev = MD5.new(prev + self.key + salt).digest()
            key_iv += prev

        derived_key = key_iv[:32]  # Use first 32 bytes for the key
        iv = key_iv[32:48]  # Use next 16 bytes for the IV
        ciphertext = encrypted_bytes[16:]

        cipher = AES.new(derived_key, AES.MODE_CBC, iv)
        decrypted_bytes = cipher.decrypt(ciphertext)
        decrypted_bytes = unpad(decrypted_bytes, AES.block_size)

        # Convert the decrypted bytes to a string

        return decrypted_bytes.decode()

    def get_cookies(self) -> dict[str, list[dict]]:
        """Fetch and decrypt cookies from CookieCloud server.

        Returns:
            dict: Dictionary of cookies organized by domain

        """
        url = f'{self.server_url}/get/{self.uuid}'
        headers = {'User-Agent': self.user_agent}

        try:
            response = self.client.get(url, headers=headers)
            response.raise_for_status()
            response_data = response.json()
            return json.loads(self._decrypt_data(response_data['encrypted']))['cookie_data']

        except httpx.RequestError as e:
            log.exception('Request error')
            msg = f'Failed to connect to CookieCloud server: {e}'
            raise ConnectionError(msg) from e

    def save_to_netscape_format(self, domain: str, output_path: str | Path) -> None:
        """Save cookies for a specific domain to Netscape cookie.txt format.

        Args:
            domain (str): The domain to extract cookies for (e.g., 'bilibili.com')
            output_path (str or Path): Path where to save the cookie file

        """
        if isinstance(output_path, str):
            output_path = Path(output_path)

        cookies = self.get_cookies()
        if domain not in cookies:
            msg = f'No cookies found for domain: {domain}'
            raise ValueError(msg)

        domain_cookies = cookies[domain]
        cookie_content = [
            '# Netscape HTTP Cookie File',
            '# https://curl.se/docs/http-cookies.html',
            '# This file was generated by CookieCloud',
        ]
        for cookie in domain_cookies:
            secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
            host_only = 'TRUE' if not cookie.get('hostOnly', True) else 'FALSE' # set Include Subdomains
            expiry = cookie.get('expirationDate', int(time.time() + 157680000))  # Default: now + 5 years
            line = f'{cookie.get("domain", "." + domain)}\t'
            line += f'{host_only}\t'
            line += f'{cookie.get("path", "/")}\t'
            line += f'{secure}\t'
            line += f'{int(expiry)}\t'
            line += f'{cookie["name"]}\t'
            line += f'{cookie["value"]}'
            cookie_content.append(line)

        output_path.write_text('\n'.join(cookie_content))
